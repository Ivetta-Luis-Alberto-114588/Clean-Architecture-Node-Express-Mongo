// .env
PORT=3000


MONGO_URL= mongodb://mongo-user:123456@localhost:27018
MONGO_DB_NAME= mystore

JWT_SEED=MiSemilla

// src/app.ts
import { envs } from "./configs/envs"
import { MongoDatabase } from "./data/mongodb/mongo-database"
import { MainRoutes } from "./presentation/routes"
import { server } from "./presentation/server"


(()=>{
    main()
})()

async function main() {
    //await bd
    await MongoDatabase.connect({
        p_mongoUrl: envs.MONGO_URL,
        p_dbName: envs.MONGO_DB_NAME
    })

    //server
    new server({
        p_port: envs.PORT, 
        p_routes: MainRoutes.getMainRoutes }).start()   
}

// src/configs/bcrypt.ts
import { compareSync, hashSync } from "bcryptjs"

export class BcryptAdapter {

    static hash(password:string): string {        
        return hashSync(password)
    }
    

    static compare(password: string, hashed: string): boolean {
        return compareSync(password, hashed)
    } 
}

// src/configs/envs.ts
import "dotenv/config"
import {get} from "env-var"



export const envs = {

    PORT: get('PORT').required().asPortNumber(),
    
    MONGO_URL: get('MONGO_URL').required().asString(),
    MONGO_DB_NAME : get('MONGO_DB_NAME').required().asString(),

    JWT_SEED: get('JWT_SEED').required().asString(),
}

// src/configs/jwt.ts
import jwt, { decode } from "jsonwebtoken"
import { envs } from "./envs"

const JWT_SEED = envs.JWT_SEED

export class JwtAdapter {

    static async generateToken(payload: Object, duration?: '2h'): Promise<string | null>{

        return new Promise((resolve)=>{
            
            
            jwt.sign(payload, JWT_SEED, {expiresIn:duration}, (err, token)=>{
                
                if(err) return resolve(null)

                 resolve(token!)   
            })
        })
    }

    static validateToken<T>(token: string): Promise<T | null>  {
        return new Promise((resolve)=>{
            jwt.verify(token, JWT_SEED, (err, decoded)=>{
                
                if(err) return resolve(null)

                resolve(decoded as T)

            })
        })
    }
}

// src/configs/validator.ts
export class Validators {
  
    static get checkEmail() {
      return /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
    } 
  
  
  }

// src/data/mongodb/models/user.model.ts
import mongoose, {Schema} from "mongoose";

const userSchema = new Schema({
    name: {
        type: String,
        required: [true, "name is required"]
    },

    email:{
        type: String,
        required: [true, "email is required"],
        unique: true
    },

    password: {
        type: String,
        required: [true, "password is required"]
    },

    img:{
        type: String
    },

    roles: {
        type: [String],
        default: ['USER_ROLE'],
        enum: ['USER_ROLE', 'ADMIN_ROLE']
    }
})

export const UserModel = mongoose.model('User', userSchema)

// src/data/mongodb/mongo-database.ts
import mongoose from "mongoose";

interface IOptions{
    p_mongoUrl: string,
    p_dbName: string
}


export class MongoDatabase {

    static async connect(options: IOptions){

        const {p_dbName, p_mongoUrl} = options

        try {
            
            await mongoose.connect(p_mongoUrl, {
                dbName: p_dbName
            })

            console.log("mongo connected")
            return true

        } catch (error) {
            console.log("mongo connection error")
            throw error;
        }
    }
}

// src/domain/datasources/auth.datasource.ts
import { LoginUserDto } from "../dtos/auth/login-user.dto";
import { RegisterUserDto } from "../dtos/auth/register-user.dto";
import { UserEntity } from "../entities/user.entity";

export abstract class AuthDatasource {


    //login
    abstract login(loginUserDto: LoginUserDto): Promise<UserEntity>

    //register
    abstract register(registerUserDto: RegisterUserDto): Promise<UserEntity>
}

// src/domain/dtos/auth/login-user.dto.ts
import { Validators } from "../../../configs/validator"


export class LoginUserDto {
    
    constructor(
        public email: string,
        public password: string
    ){}

    static login(object: {[key: string]: any}): [string?, LoginUserDto?]{

        const {email, password} = object

        if(!email) return ["email is required"]
        if(!Validators.checkEmail.test(email)) return ["email has not a valid format"]
        if(!password) return ["password is required"]


        return [undefined, new LoginUserDto(email, password)]
    }

}

// src/domain/dtos/auth/register-user.dto.ts
//  uso del patron factory
//  no se puede instanciar la clase, solo con el metodo create
//  este metodo tiene verificaciones antes de la creacion
// con las validaciones no uso librerias externas

import { Validators } from "../../../configs/validator"

export class RegisterUserDto {
    
    private constructor(
        public name: string,
        public email: string,
        public password: string
    ){}

    static create(object: {[key:string]:any}): [string?, RegisterUserDto?]{
        
        const {name, email, password} = object
        
        if(!name) return ["name is required"]
        if(!email) return ["email is required"]
        if(! Validators.checkEmail.test(email)) return ["email is not valid"]
        if(!password) return ["password is required"]
        if( password.length < 6 )  return ["password too short"]
        

        return [undefined, new RegisterUserDto(name, email, password)]
    }

}

// src/domain/entities/user.entity.ts
export class UserEntity {
    
    constructor(
        public id: string, 
        public name: string,
        public email: string,
        public password: string,
        public role: string[],
        public img?: string

    ){}
}

// src/domain/errors/custom.error.ts
export class CustomError extends Error {

    constructor(
        public readonly statusCode: number,
        public readonly message: string
    ){
        super(message)
    }

    static badRequest(message: string){
        return new CustomError(400, message)
    }

    static unauthorized(message: string){
        return new CustomError(401, message)
    }

    static forbiden(message: string){
        return new CustomError(403, message)
    }

    static notFound(message: string){
        return new CustomError(404, message)
    }

    static internalServerError(message: string = "Internal Server Error"){
        console.log(message)
        return new CustomError(500, message)
    }
}

// src/domain/repositories/auth.repository.ts
import { LoginUserDto } from "../dtos/auth/login-user.dto";
import { RegisterUserDto } from "../dtos/auth/register-user.dto";
import { UserEntity } from "../entities/user.entity";

export abstract class AuthRepository {


    //login
    abstract login(loginUserDto: LoginUserDto): Promise<UserEntity>

    //register
    abstract register(registerUserDto: RegisterUserDto): Promise<UserEntity>
}

// src/domain/use-cases/auth/login-user.use-case.ts
import { JwtAdapter } from "../../../configs/jwt";
import { LoginUserDto } from "../../dtos/auth/login-user.dto";
import { RegisterUserDto } from "../../dtos/auth/register-user.dto";
import { CustomError } from "../../errors/custom.error";
import { AuthRepository } from "../../repositories/auth.repository";

interface LoginUserUseCase{
    execute (registerUserDto: RegisterUserDto): Promise<UserToken>
}

interface UserToken{
    token: string,
    user: {
        id: string, 
        name: string,
        email: string
    }
}

//es como una interfaz pero para una funcion
type SignToken = (payload: Object, duration?: "2h") => Promise<string | null>
            

export class LoginUser implements LoginUserUseCase {
    
    constructor(
        private readonly authRepository: AuthRepository,
        private readonly signToken: SignToken = JwtAdapter.generateToken
    ){}
    
    async execute(loginUserDto: LoginUserDto): Promise<UserToken> {
        
        //crear usuario
        const user = await this.authRepository.login(loginUserDto)
        

        //token
        const token = await this.signToken({id: user.id}, '2h')

        if(!token) throw CustomError.internalServerError("error generating token")



        return {
            token: token,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,

            }
        }
    }

}

// src/domain/use-cases/auth/register-user.use-case.ts
import { JwtAdapter } from "../../../configs/jwt";
import { RegisterUserDto } from "../../dtos/auth/register-user.dto";
import { CustomError } from "../../errors/custom.error";
import { AuthRepository } from "../../repositories/auth.repository";

interface RegisterUserUseCase{
    execute (registerUserDto: RegisterUserDto): Promise<UserToken>
}

interface UserToken{
    token: string,
    user: {
        id: string, 
        name: string,
        email: string
    }
}

//es como una interfaz pero para una funcion
type SignToken = (payload: Object, duration?: "2h") => Promise<string | null>
            

export class RegisterUser implements RegisterUserUseCase {
    
    constructor(
        private readonly authRepository: AuthRepository,
        private readonly signToken: SignToken = JwtAdapter.generateToken
    ){}
    
    async execute(registerUserDto: RegisterUserDto): Promise<UserToken> {
        
        //crear usuario
        const user = await this.authRepository.register(registerUserDto)
        

        //token
        const token = await this.signToken({id: user.id}, '2h')

        if(!token) throw CustomError.internalServerError("error generating token")



        return {
            token: token,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,

            }
        }
    }

}

// src/infrastructure/datasources/auth.datasource.impl.ts
import { BcryptAdapter } from "../../configs/bcrypt";
import { UserModel } from "../../data/mongodb/models/user.model";
import { AuthDatasource } from "../../domain/datasources/auth.datasource";
import { LoginUserDto } from "../../domain/dtos/auth/login-user.dto";
import { RegisterUserDto } from "../../domain/dtos/auth/register-user.dto";
import { UserEntity } from "../../domain/entities/user.entity";
import { CustomError } from "../../domain/errors/custom.error";
import { UserMapper } from "../mappers/user.mapper";


//estoy creando como unas interfaces para tipar 
type HashFunction = (password: string) => string
type CompareFunction = (password: string, hashed: string) => boolean


export class AuthDatasourceImpl implements AuthDatasource{
    
    constructor(
        private readonly hashPassword: HashFunction = BcryptAdapter.hash,
        private readonly comparePassword: CompareFunction = BcryptAdapter.compare
    ){}

    async login(loginUserDto: LoginUserDto): Promise<UserEntity> {
        const {email, password} = loginUserDto


        try {

            const user = await UserModel.findOne({email: email})

            if(!user) throw CustomError.badRequest("user does not exists - email")

            const isPasswordMatching = this.comparePassword(password, user.password)

            if(!isPasswordMatching) throw CustomError.badRequest("password is not valid")

            return UserMapper.userEntityFromObject(user)    
            
        } catch (error) {
            console.log(error)
            throw CustomError.internalServerError()
        }


    }


    async register(registerUserDto: RegisterUserDto): Promise<UserEntity> {
    
        const {name, email, password} = registerUserDto

        try {

            //1 verificar correo
            const exists = await UserModel.findOne({email: email})
            if(exists) throw CustomError.badRequest('user already exists')

            //2 encritar la contrase√±a
            const passwordHashed = this.hashPassword(password)


            //creo el usuario con el modelo
            const user = await UserModel.create({
                name: name,
                email: email,
                password: passwordHashed
            })

            //guardo el user en la bd
            await user.save()


            //3 mapear la respuesa nuestra entidad
            return UserMapper.userEntityFromObject(user)
            
        } catch (error) {
            
            if(error instanceof CustomError){
                throw error
            }

            throw CustomError.internalServerError()
        }
    
    }

}

// src/infrastructure/mappers/user.mapper.ts
import { UserEntity } from "../../domain/entities/user.entity";
import { CustomError } from "../../domain/errors/custom.error";

export class UserMapper {

    static userEntityFromObject(object: {[key: string]: any}){

        const {_id, id, name, email, password, roles} = object

        if(!_id || !id) throw CustomError.badRequest('missing id')
        if(!name) throw CustomError.badRequest("missing name")
        if(!email) throw CustomError.badRequest("missing email")
        if(!password) throw CustomError.badRequest("missing password")
        if(!roles) throw CustomError.badRequest("missing roles")


        return new UserEntity(
            _id || id,
            name,
            email,
            password,
            roles 
        )
    }
}

// src/infrastructure/repositories/auth.repository.impl.ts
import { AuthDatasource } from "../../domain/datasources/auth.datasource";
import { LoginUserDto } from "../../domain/dtos/auth/login-user.dto";
import { RegisterUserDto } from "../../domain/dtos/auth/register-user.dto";
import { UserEntity } from "../../domain/entities/user.entity";
import { AuthRepository } from "../../domain/repositories/auth.repository";


export class AuthRepositoryImpl implements AuthRepository {
    
    constructor(
        private readonly authDatasource: AuthDatasource
    ){}
    login(loginUserDto: LoginUserDto): Promise<UserEntity> {
        return this.authDatasource.login(loginUserDto)
    }

    register(registerUserDto: RegisterUserDto): Promise<UserEntity> {
        return this.authDatasource.register(registerUserDto)
    }


}

// src/presentation/auth/controller.auth.ts
import {NextFunction, Request, Response} from "express"
import { RegisterUserDto } from "../../domain/dtos/auth/register-user.dto"
import { AuthRepository } from "../../domain/repositories/auth.repository"
import { CustomError } from "../../domain/errors/custom.error"
import { JwtAdapter } from "../../configs/jwt"
import { UserModel } from "../../data/mongodb/models/user.model"
import { RegisterUser } from "../../domain/use-cases/auth/register-user.use-case"
import { LoginUserDto } from "../../domain/dtos/auth/login-user.dto"
import { LoginUser } from "../../domain/use-cases/auth/login-user.use-case"

export class AuthController {

    constructor(
        private readonly authRepository: AuthRepository
    ) {}

    private handleError = (error: unknown, res: Response) => {
        if(error instanceof CustomError){
            return res.status(error.statusCode).json({error: error.message});
        }
    
        console.log(error);
        return res.status(500).json({error: "internal server error"});
    }


    registerUser = (req: Request, res: Response): void => {
        const [error, registerUserDto] = RegisterUserDto.create(req.body);
    
        if (error) {
             res.status(400).json({ error });
        }
        
        new RegisterUser(this.authRepository)
            .execute(registerUserDto!)
            .then(data => res.json(data))
            .catch(err => this.handleError(err, res))       

    }

    loginUser =  (req: Request, res: Response)=>{
        const [error, loginUserDto] = LoginUserDto.login(req.body);
    
        if (error) {
             res.status(400).json({ error });
        }
        
        new LoginUser(this.authRepository)
            .execute(loginUserDto!)
            .then(data => res.json(data))
            .catch(err => this.handleError(err, res))     
    }

    getUsers = (req: Request, res: Response)=>{
        UserModel.find()
            .then(users => {
                
                return res.json({
                    //users,
                    user: req.body.user
                })
            })
            .catch(x=> res.status(500).send({error: "internal server error"}))
    }
}

// src/presentation/auth/routes.auth.ts
import { Router } from "express";
import { AuthController } from "./controller.auth";
import { AuthRepositoryImpl } from "../../infrastructure/repositories/auth.repository.impl";
import { AuthDatasourceImpl } from "../../infrastructure/datasources/auth.datasource.impl";
import { AuthMiddleware } from "../middlewares/auth.middleware";



export class AuthRoutes { 

    static get getAuthRoutes() : Router {
        
        const router = Router()
        const database = new AuthDatasourceImpl()
        const authRepository = new AuthRepositoryImpl(database)
        const controller = new AuthController(authRepository)

        router.post("/register", controller.registerUser)
        router.post("/login", controller.loginUser)
        router.get("/", AuthMiddleware.validateJwt, controller.getUsers)
        
        
        return router
    }


}

// src/presentation/middlewares/auth.middleware.ts
import { NextFunction, Request, Response } from "express";
import { JwtAdapter } from "../../configs/jwt";
import { UserModel } from "../../data/mongodb/models/user.model";

export class AuthMiddleware {


    static  validateJwt = async (req: Request, res: Response, next: NextFunction) =>{

        const authorization = req.header('Authorization')
        
        if(!authorization) {
             res.status(401).json({error: "no token"})            
             return
        }

        if(!authorization!.startsWith("Bearer ")) {
             res.status(401).json({error: "no bearer"})
             return
        } 
        
        const token = authorization!.split(' ')[1] || ""

        try {

            //todo
            const payload = await JwtAdapter.validateToken<{id: string}>(token)

            if(!payload){
                res.status(401).json({error: "token invalid"})
                return
            }

            

            const user = await UserModel.findById(payload.id)

            if(!user){
                res.status(401).json({error: "invalid token - user not found"})
            }

            req.body.user = user
            
            next();

        } catch (error) {
            console.log(error)
            res.status(500).json({error: "internal sever error"})
            
        }
        
    }
}

// src/presentation/routes.ts
import { Router } from "express";
import { AuthRoutes } from "./auth/routes.auth";



export class MainRoutes { 

    static get getMainRoutes() : Router {
        
        const router = Router()

        router.use("/api/auth", AuthRoutes.getAuthRoutes)
        // router.use("/api/user")
        // router.use("/api/products")
        // router.use("/api/clients")
        // router.use("/api/orders")
        
        return router
    }


}

// src/presentation/server.ts
import express, { Router } from "express"
import { MainRoutes } from "./routes"

interface IOptions {
    p_port: number,
    p_routes: Router
}


export class server {

    public readonly app = express()
    private readonly port : number
    private readonly route: Router

    constructor(options: IOptions){
        const {p_port, p_routes} = options
        
        this.port = p_port
        this.route = p_routes
    }

    async start(){

        this.app.use(express.json())
        this.app.use(MainRoutes.getMainRoutes)

        this.app.listen(this.port, ()=>{
            console.log("server running on port", this.port)
        })

    }

}

// docker-compose.yml
version: '3.8'


services:

  mongo-db:
    image: mongo:6.0.6
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: mongo-user
      MONGO_INITDB_ROOT_PASSWORD: 123456
    volumes:
      - ./mongo:/data/db
    ports:
      - 27018:27017

